<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Y11en</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                首页
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                归档
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                标签
            </a>
            

            
            <a href="/about/" class="header-nav-link">
                关于
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">y11en's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2017/03/05/%5B%E9%80%86%E5%90%91%E7%AF%87%5Darm%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/">arm指令学习</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2017-03-05</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="1-arm汇编基础"><a href="#1-arm汇编基础" class="headerlink" title="1. arm汇编基础"></a>1. arm汇编基础</h2><h3 id="1-LDMIA-R0-R1-R2-R3-R4"><a href="#1-LDMIA-R0-R1-R2-R3-R4" class="headerlink" title="1. LDMIA R0 , {R1,R2,R3,R4}"></a>1. LDMIA R0 , {R1,R2,R3,R4}</h3><p>LDM为: 多寄存器”内存取”指令<br>IA表示每次LDM指令结束之后R0增加1个字<br>最终结果为R1 = [R0], R1 = [R0+#4], R1 = [R0+#8], R1 = [R0+#0xC]</p>
<h3 id="2-堆栈寻址-FA、EA、FD、ED"><a href="#2-堆栈寻址-FA、EA、FD、ED" class="headerlink" title="2. 堆栈寻址 (FA、EA、FD、ED)"></a>2. 堆栈寻址 (FA、EA、FD、ED)</h3><p>STMFD SP! , {R1-R7,LR} @ 将R1<del>R7以及LR入栈<br>LDMFD SP! , {R1-R7,LR} @ 将R1</del>R7以及LR出栈</p>
<h3 id="3-块拷贝寻址"><a href="#3-块拷贝寻址" class="headerlink" title="3. 块拷贝寻址"></a>3. 块拷贝寻址</h3><p>LDM和STM为指令前缀，表示多寄存器寻址，指令后缀(IA、DA、IB、DB)。<br>LDMIA R0!, {R1-R3}  @从R0所指向的内存地址依次取出3个字到R1、R2、R3寄存器<br>STMIA R0!, {R1-R3}  @将R1、R2、R3所存储的内容依次存放在R0所指向的内存。</p>
<h3 id="4-相对寻址"><a href="#4-相对寻址" class="headerlink" title="4. 相对寻址"></a>4. 相对寻址</h3><pre><code>以当前程序计数器PC的当前值为基地址，将标号标记位置为偏移量，两者相加得
到有效地址。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BL NEXT</span><br><span class="line">    ...        </span><br><span class="line">NEXT:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></code></pre><h2 id="2-指令集"><a href="#2-指令集" class="headerlink" title="2. 指令集"></a>2. 指令集</h2><h3 id="1-由于arm芯片更新很快，所以指令集很多，使用较为普遍的就是arm指令集以及Thumb指令集。"><a href="#1-由于arm芯片更新很快，所以指令集很多，使用较为普遍的就是arm指令集以及Thumb指令集。" class="headerlink" title="1. 由于arm芯片更新很快，所以指令集很多，使用较为普遍的就是arm指令集以及Thumb指令集。"></a>1. 由于arm芯片更新很快，所以指令集很多，使用较为普遍的就是arm指令集以及Thumb指令集。</h3><p><img src="~/20-47-17.jpg" alt=""><br><img src="~/20-47-25.jpg" alt=""><br><img src="~/20-41-45.jpg" alt=""><br><img src="~/20-47-45.jpg" alt=""><br><img src="~/20-47-55.jpg" alt=""></p>
<h3 id="2-跳转指令"><a href="#2-跳转指令" class="headerlink" title="2.跳转指令"></a>2.跳转指令</h3><p>arm实现了两种跳转类型，一种是直接使用跳转指令，另外一种则是给PC寄存器直接赋值。</p>
<h4 id="1-B跳转指令"><a href="#1-B跳转指令" class="headerlink" title="1. B跳转指令"></a>1. B跳转指令</h4><pre><code>结构 B{cond} label    
直接跳走，如`BNE LABEL`</code></pre><h4 id="2-BL跳转指令"><a href="#2-BL跳转指令" class="headerlink" title="2. BL跳转指令"></a>2. BL跳转指令</h4><pre><code>结构 BL{cond} label    
执行BL指令时，若条件满足，则首先将当前指令的下一条指令的地址赋值给R14寄存器(LR)，然
后跳转到label标记的地址处继续执行。一般用在过程调用中，过程结束之后通过`MOV PC, LR`返回</code></pre><h4 id="3-BX带状态切换的跳转指令"><a href="#3-BX带状态切换的跳转指令" class="headerlink" title="3. BX带状态切换的跳转指令"></a>3. BX带状态切换的跳转指令</h4><pre><code>结构 BX{cond}Rm   
当执行BX指令时，如果条件满足，会判断Rm寄存器的位[0]是否为1，如果是1则会在跳转时自动将CPSR寄存器的T标志位置为1,并将目标位置处的指令解析为Thumb指令，相反，若Rm寄存器的位[0]为0，则将CPSR寄存器的T标志位复位，同时将目标位置的指令解析为arm指令。</code></pre><p> 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ADR R0, thumbcode + 1</span><br><span class="line">BX R0       @跳转到thumbcode。并且处理器运行为thumb模式</span><br><span class="line">thumbcode:</span><br><span class="line">.code 16</span><br></pre></td></tr></table></figure>
<h4 id="4-BLX带链接和状态切换的跳转指令"><a href="#4-BLX带链接和状态切换的跳转指令" class="headerlink" title="4.BLX带链接和状态切换的跳转指令"></a>4.BLX带链接和状态切换的跳转指令</h4><pre><code>结构 BLX{cond}Rm
BLX指令集合了BL和BX的功能，在BX的功能上同时保存返回地址到R14(LR)</code></pre><h3 id="3-寄存器访问指令"><a href="#3-寄存器访问指令" class="headerlink" title="3.寄存器访问指令"></a>3.寄存器访问指令</h3><p>存储器访问指令操作包括从存储区加载数据，存储数据到存储器，寄存器与存储器之间的数据交换等。</p>
<h4 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a><code>LDR</code></h4><p>指令包括:<br><code>LDR{type}{cond}Rd,label</code><br><code>LDRD{cond}Rd,Rd2,label</code><br>其中type表示操作的数据大小，取值如下</p>
<p><img src="~/21-36-36.jpg" alt=""><br><img src="~/21-37-48.jpg" alt=""><br>LDRD依次加载双字的数据,用法如下：<br><code>LDRD R0, R1, label2</code>@从标号labe2加载两个字到R0,R1中</p>
<h4 id="STR"><a href="#STR" class="headerlink" title="STR"></a><code>STR</code></h4><p>STR用于存储数据到制定地址。格式如下：<br>STR{type}{cond}Rd,label<br>STRD{cond}Rd,Rd2,label<br>用法如下:<br><code>STR R0,[R2,#04]</code> 将R0的值存储到R2+4的地址处</p>
<h4 id="LDM"><a href="#LDM" class="headerlink" title="LDM"></a><code>LDM</code></h4><p><code>LDM{addr_mode}{cond}Rn{!}reglist</code></p>
<p><img src="~/21-44-36.jpg" alt=""></p>
<blockquote>
<p>特别注意, ! 为可选后缀。如果有 ! 则最终地址会写回到Rn寄存器</p>
</blockquote>
<h4 id="STM"><a href="#STM" class="headerlink" title="STM"></a><code>STM</code></h4><p>STM将一个寄存器列表的数据存储到指定的地址单元中。格式如下</p>
<p><code>STM{addr_mod}{cond}Rn{!}reglist</code></p>
<h4 id="PUSH-amp-amp-POP"><a href="#PUSH-amp-amp-POP" class="headerlink" title="PUSH&amp;&amp;POP"></a><code>PUSH&amp;&amp;POP</code></h4><p>格式如下：<br>PUSH{cond}reglist<br>POP{cond}reglist<br>栈操作指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUSH &#123;r0,r4-r7&#125;</span><br><span class="line">POP &#123;r0,r4-r7&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SWP"><a href="#SWP" class="headerlink" title="SWP"></a><code>SWP</code></h4><p>寄存器之间的数据交换。<br>格式为<code>SWP{B}{cond}Rd,Rm,[Rn]</code><br>B是可选的字节，若有B，则交换字节，否则交换字<br>Rd为临时存放的寄存器，Rm是<code>要替换</code>的值<br>Rn是<code>要被替换</code>的数据地址</p>
<h2 id="其他逻辑、运算指令，具体还是看手册了解…"><a href="#其他逻辑、运算指令，具体还是看手册了解…" class="headerlink" title="其他逻辑、运算指令，具体还是看手册了解…"></a>其他逻辑、运算指令，具体还是看手册了解…</h2><p>—未完待续—</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2017/03/03/%5B%E5%BC%80%E5%8F%91%E7%AF%87%5Dandroid%E5%BC%80%E5%8F%91%E4%B9%8B%E9%80%9A%E7%9F%A5%E6%A0%8F%E6%B6%88%E6%81%AF/">android开发之通知栏消息</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2017-03-03</span>
                
            </div>
            <div class="post-content">
                
                    <p>Demo功能，在A中点击按钮，弹出通知栏消息，点击消息之后转入B中，实现如下:<br><code>MainActivity</code>的布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.cn.yllen.notificationtest.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button_notifiy"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Send notice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Notification;</span><br><span class="line"><span class="keyword">import</span> android.app.NotificationManager;</span><br><span class="line"><span class="keyword">import</span> android.app.PendingIntent;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.NotificationCompat;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button = (Button) findViewById(R.id.button_notifiy);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(v.getId())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button_notifiy:</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,NotificationActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">//异步消息</span></span><br><span class="line">                PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line">                NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">                Notification  notification = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>).setContentText(<span class="string">"This is a Test Notice"</span>)</span><br><span class="line">                        .setContentTitle(<span class="string">"Notice"</span>).setWhen(System.currentTimeMillis())</span><br><span class="line">                        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                        .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))</span><br><span class="line">                        .setContentIntent(pi)           <span class="comment">//延迟处理intent</span></span><br><span class="line">                        .setAutoCancel(<span class="keyword">true</span>)            <span class="comment">//点击后消失</span></span><br><span class="line">                        .build();</span><br><span class="line">                manager.notify(<span class="number">1</span>,notification);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NotificationActivity</code>的布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.cn.yllen.notificationtest.NotificationActivity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">"24sp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"This is notification layout~~"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.NotificationManager;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_notification);</span><br><span class="line">        <span class="comment">//NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span></span><br><span class="line">        <span class="comment">//notificationManager.cancel(1);      //关闭id=1的消息框</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2016/12/11/%E4%BA%AC%E4%B8%9C%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E4%BA%8B%E4%BB%B6/">京东数据泄露事件</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2016-12-11</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="京东数据泄露事件"><a href="#京东数据泄露事件" class="headerlink" title="京东数据泄露事件"></a>京东数据泄露事件</h2><h3 id="0x01本次事件的报道者是名为【一本财经】的微信公众号所发布"><a href="#0x01本次事件的报道者是名为【一本财经】的微信公众号所发布" class="headerlink" title="0x01本次事件的报道者是名为【一本财经】的微信公众号所发布"></a>0x01本次事件的报道者是名为【一本财经】的微信公众号所发布</h3><p><img src="./09-05-28.png" alt=""></p>
<h3 id="0x02事件“主角”京东方面于11日在其运营的【京东黑板报】微信公众号进行了申明，申明如下："><a href="#0x02事件“主角”京东方面于11日在其运营的【京东黑板报】微信公众号进行了申明，申明如下：" class="headerlink" title="0x02事件“主角”京东方面于11日在其运营的【京东黑板报】微信公众号进行了申明，申明如下："></a>0x02事件“主角”京东方面于11日在其运营的【京东黑板报】微信公众号进行了申明，申明如下：</h3><p><img src="./09-05-35.png" alt=""></p>
<h3 id="0x03官方回复是否属实？"><a href="#0x03官方回复是否属实？" class="headerlink" title="0x03官方回复是否属实？"></a>0x03官方回复是否属实？</h3><p>通过相关检索，获取到乌云网镜像数据，从中搜索<code>京东</code>关键字定位到官方提到的<code>Struts 2</code>漏洞，如下：</p>
<p><img src="./09-13-30.jpg" alt=""></p>
<p><img src="./09-14-20.jpg" alt=""><br><code>Struts 2</code> 的漏洞提交从7-17开始到24日逐渐结束，共经历了<code>9</code>天，其中京东对提交的漏洞统一回复为：</p>
<p><img src="./09-18-41.jpg" alt=""></p>
<p>本次<code>京东 泄漏</code>事件 造成的影响:</p>
<p><img src="./09-33-38.jpg" alt=""></p>
<p><img src="./09-34-01.jpg" alt=""></p>
<p><img src="./09-34-29.jpg" alt=""></p>
<h3 id="0x04-对于京东用户导致的影响："><a href="#0x04-对于京东用户导致的影响：" class="headerlink" title="0x04 对于京东用户导致的影响："></a>0x04 对于京东用户导致的影响：</h3><ul>
<li>个人隐私信息泄漏，遭到骚扰或者勒索</li>
<li>个人财产可能被盗用、窃取</li>
</ul>
<h3 id="0x05-小疑问："><a href="#0x05-小疑问：" class="headerlink" title="0x05 小疑问："></a>0x05 小疑问：</h3><ul>
<li>爆料者为何选择这么一个比较特殊的<code>年底</code>,<code>非工作日</code>,<code>双十二前夕</code>日子<code>发难</code>？ </li>
<li>哪里有泄漏的数据？</li>
</ul>
<p>Ref:<br>该漏洞官方介绍地址：<br><code>http://struts.apache.org/docs/s2-016.html</code></p>
<p>以下是 <code>FreeBuf</code>对3年前的漏洞相关文章<code>http://www.freebuf.com/vuls/11220.html</code></p>
<p><code>FreeBuf</code>对此事件的报道：<br><code>http://www.freebuf.com/news/122524.html</code></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2016/09/29/%5BMob_Sec_1%5DAndroid_ptrace_inject/">android_ptrace_inject</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2016-09-29</span>
                
            </div>
            <div class="post-content">
                
                    <p>##0x1 前文<br><code>注入</code>，Windows平台下一个极其有意思的一门技术，作为绝大多数<code>Hook</code>方案的前奏，当然是各种姿势都有，限于本人能力之有限，会逐渐记录移动端安全相关的学习过程，也希望看到本篇的朋友，能学到一些东西。废话不说了，走起!(<code>以下代码可能存在高度风险性，请勿用于非法用途，一切使用中造成的任何后果，均与本人以及所参考的文章作者无关，继续阅读默认你同意且遵守本括号中的描述</code>)<br>##0x2 ptrace<br>ptrace是linux系统下用于调试进程用的，具体描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AME</span><br><span class="line">       ptrace - process trace</span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys&#x2F;ptrace.h&gt;</span><br><span class="line">       long ptrace(enum __ptrace_request request, pid_t pid,</span><br><span class="line">                   void *addr, void *data);</span><br><span class="line">DESCRIPTION</span><br><span class="line">   The  ptrace()  system  call  provides  a  means by which one process (the &quot;tracer&quot;) may observe and control the execution of another process (the &quot;tracee&quot;), and examine and change the tracee&#39;s memory and registers.  It is primarily used to implement breakpoint debugging and system call tracing.</span><br></pre></td></tr></table></figure>
<p>重点在于<code>第一个参数</code>，可取的值如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PTRACE_ME</span><br><span class="line"></span><br><span class="line">PTRACE_PEEKTEXT</span><br><span class="line"></span><br><span class="line">PTRACE_PEEKDATA</span><br><span class="line"></span><br><span class="line">PTRACE_PEEKUSER</span><br><span class="line"></span><br><span class="line">PTRACE_POKETEXT</span><br><span class="line"></span><br><span class="line">PTRACE_POKEDATA</span><br><span class="line"></span><br><span class="line">PTRACE_POKEUSER</span><br><span class="line"></span><br><span class="line">PTRACE_GETREGS</span><br><span class="line"></span><br><span class="line">PTRACE_GETFPREGS,</span><br><span class="line"></span><br><span class="line">PTRACE_SETREGS</span><br><span class="line"></span><br><span class="line">PTRACE_SETFPREGS</span><br><span class="line"></span><br><span class="line">PTRACE_CONT</span><br><span class="line"></span><br><span class="line">PTRACE_SYSCALL,</span><br><span class="line"></span><br><span class="line">PTRACE_SINGLESTEP</span><br><span class="line"></span><br><span class="line">PTRACE_DETACH</span><br></pre></td></tr></table></figure>
<h2 id="0x3-ptrace注入原理"><a href="#0x3-ptrace注入原理" class="headerlink" title="0x3 ptrace注入原理"></a>0x3 ptrace注入原理</h2><p>ptrace注入的原理就是，首先attach到指定进程，这里需要给一个进程的pid，然后通过修改 IP ，指向一段load so的代码，之后获取要执行的函数地址，然后转入执行。大致有两种方式实现：一种是调用dlopen\dlsym然后执行到我们的so模块内，第二种是直接注入一段shellcode。<br>类似于 Windows 下的debug模式进程的注入 ，具体可以参考  <code>http://blog.csdn.net/wowolook/article/details/10055329</code>。</p>
<h2 id="0x4-测试截图"><a href="#0x4-测试截图" class="headerlink" title="0x4 测试截图"></a>0x4 测试截图</h2><p> 首先将编译好的inject 程序拷贝到 /data目录下（android虚拟机或者实体机，需要root权限） ，之后使用 <code>chmod 777 inject</code>，然后输入 <code>./inject</code>回车<br><img src="~/19-47-09.jpg" alt=""><br>注入成功！<br><img src="~/19-47-58.jpg" alt=""><br>日志<br><img src="~/19-48-39.jpg" alt=""><br>需要注意本代码中注入的进程是 <code>com.example.yllen.myapplication</code>，所以当前进程列表中是要存在这个的，实际测试中可以替换为你需要注入的进程名称，或者可以稍微改改支持命令行输入进程名称的，想必聪明的你肯定分分钟搞定。</p>
<p>##0x5 注入流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. ptrace_attach(pid) 附加到进程</span><br><span class="line">2. ptrace_getregs(pid,&amp;CurrentRegs) 保存主线程上下文</span><br><span class="line">3. GetRemoteFuncAddr(pid,libc_path,(void*)mmap); 获取mmap的地址，用来分配一段内存，主要存放so路径、要执行的远程函数名称</span><br><span class="line">4.设置mmap的参数，然后调用</span><br><span class="line">5.获取 dlopen、dlsym、dlclose、dlerror函数的地址</span><br><span class="line"> 	&#x2F;&#x2F; 分别获取dlopen、dlsym、dlclose等函数的地址</span><br><span class="line">	dlopen_addr &#x3D; GetRemoteFuncAddr(pid, linker_path, (void *)dlopen);</span><br><span class="line">	dlsym_addr &#x3D; GetRemoteFuncAddr(pid, linker_path, (void *)dlsym);</span><br><span class="line">	dlclose_addr &#x3D; GetRemoteFuncAddr(pid, linker_path, (void *)dlclose);</span><br><span class="line">	dlerror_addr &#x3D; GetRemoteFuncAddr(pid, linker_path, (void *)dlerror);</span><br><span class="line">6. ptrace_writedata(pid,RemoteMapMemoryAddr,LibPath,strlen(LibPath)+1) 写入要注入的so文件路径</span><br><span class="line">7.设置dlopen函数的参数，然后调用,读取返回值(r0)得到起始地址</span><br><span class="line">8.ptrace_writedata(pid, RemoteMapMemoryAddr + strlen(LibPath) + 2, FunctionName, strlen(FunctionName) + 1) 吸入要执行的函数地址，然后调用dlsym，通过读取返回值(r0)得到函数地址</span><br><span class="line">9.传递参数(如果有),调用函数</span><br><span class="line">10. 通过上述步骤，使得自己的函数在指定进程内执行，之后调用ptrace_detach断开进程连接</span><br><span class="line"></span><br><span class="line">注：上文所述的ptrace_xx函数都是封装好的ptrace功能函数</span><br></pre></td></tr></table></figure>
<p>##0x6 源代码</p>
<p>下面就是源码了。<br>源文件由4个部分组成，分别为inject.h 、inject.c、main.c、PrintLog.h构成</p>
<ol>
<li>inject.h 、inject.c 注入功能</li>
<li>main.c 发起注入</li>
<li>PrintLog.h 打印日志的封装</li>
</ol>
<p>由于本人对arm汇编并不熟练，所以<code>shellcode</code>版的代码就不贴了，等日后逐渐熟练会一一进行分析。</p>
<h3 id="以下代码为dlopen-dlsym-版ptrace-注入，至于如何防御，等以后有机会再补充。"><a href="#以下代码为dlopen-dlsym-版ptrace-注入，至于如何防御，等以后有机会再补充。" class="headerlink" title="以下代码为dlopen/dlsym 版ptrace 注入，至于如何防御，等以后有机会再补充。"></a>以下代码为dlopen/dlsym 版ptrace 注入，至于如何防御，等以后有机会再补充。</h3><p>先是简单的 PrintLog.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*PrintLog.h*/</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> _ANDROID_LOG_PRINT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ANDROID_LOG_PRINT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IS_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG (<span class="meta-string">"INJECT"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGV(...) ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG  , LOG_TAG, __VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO   , LOG_TAG, __VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN   , LOG_TAG, __VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR  , LOG_TAG, __VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGV(LOG_TAG, ...) NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(LOG_TAG, ...) NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(LOG_TAG, ...) NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGW(LOG_TAG, ...) NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(LOG_TAG, ...) NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> 接下来是 inject.h </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*inject.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_PATH 0x100</span></span><br><span class="line"><span class="comment">// dlopen dlsym 注入</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">inject_remote_process</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">char</span>* LibPath,<span class="keyword">char</span>* FunctionName,<span class="keyword">long</span>* FuncParameter ,<span class="keyword">long</span> NumParameter)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*inject.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/user.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/PrintLog.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPSR_T_MASK     ( 1u &lt;&lt; 5 )</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *libc_path = <span class="string">"/system/lib/libc.so"</span>;    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *linker_path = <span class="string">"/system/bin/linker"</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    ptrace使远程进程继续运行</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示continue成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_continue</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_CONT, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"ptrace cont error, pid:%d"</span>, pid);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace Attach到指定进程</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示attach成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_attach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        LOGD(<span class="string">"attach process error, pid:%d"</span>, pid);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">	</span><br><span class="line"> 	LOGD(<span class="string">"attach process pid:%d"</span>, pid);          </span><br><span class="line">    waitpid(pid, &amp;status , WUNTRACED);       	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace detach指定进程</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示detach成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_detach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        LOGD(<span class="string">"detach process error, pid:%d"</span>, pid);     </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">	LOGD(<span class="string">"detach process pid:%d"</span>, pid);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace获取远程进程的寄存器值</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，regs为pt_regs结构，存储了寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示获取寄存器成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_getregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Get Regs error, pid:%d"</span>, pid);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace设置远程进程的寄存器值</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，regs为pt_regs结构，存储需要修改的寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示设置寄存器成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_setregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Set Regs error, pid:%d"</span>, pid);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    获取返回值，ARM处理器中返回值存放在ARM_r0寄存器中</span></span><br><span class="line"><span class="comment">  Input:          regs存储远程进程当前的寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         在ARM处理器下返回r0寄存器值</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_getret</span><span class="params">(struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ARM_r0;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    获取当前执行代码的地址，ARM处理器下存放在ARM_pc中</span></span><br><span class="line"><span class="comment">  Input:          regs存储远程进程当前的寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         在ARM处理器下返回pc寄存器值</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_getpc</span><span class="params">(struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ARM_pc;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace从远程进程内存中读取数据</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，pSrcBuf表示从远程进程读取数据的内存地址</span></span><br><span class="line"><span class="comment">				  pDestBuf表示用于存储读取出数据的地址，size表示读取数据的大小</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示读取数据成功</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_readdata</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint8_t</span> *pSrcBuf, <span class="keyword">uint8_t</span> *pDestBuf, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> nReadCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> nRemainCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurSrcBuf = pSrcBuf;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurDestBuf = pDestBuf;</span><br><span class="line">	<span class="keyword">long</span> lTmpBuf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> i = <span class="number">0</span>;	</span><br><span class="line"> </span><br><span class="line">	nReadCount = <span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	nRemainCount = <span class="built_in">size</span> % <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nReadCount; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		lTmpBuf = ptrace(PTRACE_PEEKTEXT, pid, pCurSrcBuf, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(pCurDestBuf, (<span class="keyword">char</span> *)(&amp;lTmpBuf), <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">		pCurSrcBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">		pCurDestBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( nRemainCount &gt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		lTmpBuf = ptrace(PTRACE_PEEKTEXT, pid, pCurSrcBuf, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(pCurDestBuf, (<span class="keyword">char</span> *)(&amp;lTmpBuf), nRemainCount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace将数据写入到远程进程空间中</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，pWriteAddr表示写入数据到远程进程的内存地址</span></span><br><span class="line"><span class="comment">				  pWriteData用于存储写入数据的地址，size表示写入数据的大小</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示写入数据成功，返回-1表示写入数据失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_writedata</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint8_t</span> *pWriteAddr, <span class="keyword">uint8_t</span> *pWriteData, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> nWriteCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> nRemainCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurSrcBuf = pWriteData;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurDestBuf = pWriteAddr;</span><br><span class="line">	<span class="keyword">long</span> lTmpBuf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	nWriteCount = <span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	nRemainCount = <span class="built_in">size</span> % <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先讲数据以sizeof(long)字节大小为单位写入到远程进程内存空间中</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nWriteCount; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(&amp;lTmpBuf), pCurSrcBuf, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">		<span class="keyword">if</span> (ptrace(PTRACE_POKETEXT, pid, pCurDestBuf, lTmpBuf) &lt; <span class="number">0</span>)  <span class="comment">// PTRACE_POKETEXT表示从远程内存空间写入一个sizeof(long)大小的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			LOGD(<span class="string">"Write Remote Memory error, MemoryAddr:0x%lx"</span>, (<span class="keyword">long</span>)pCurDestBuf);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pCurSrcBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">		pCurDestBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将剩下的数据写入到远程进程内存空间中</span></span><br><span class="line">	<span class="keyword">if</span> (nRemainCount &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		lTmpBuf = ptrace(PTRACE_PEEKTEXT, pid, pCurDestBuf, <span class="literal">NULL</span>); <span class="comment">//先取出原内存中的数据，然后将要写入的数据以单字节形式填充到低字节处</span></span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(&amp;lTmpBuf), pCurSrcBuf, nRemainCount);</span><br><span class="line">		<span class="keyword">if</span> (ptrace(PTRACE_POKETEXT, pid, pCurDestBuf, lTmpBuf) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LOGD(<span class="string">"Write Remote Memory error, MemoryAddr:0x%lx"</span>, (<span class="keyword">long</span>)pCurDestBuf);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace远程call函数</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，ExecuteAddr为远程进程函数的地址</span></span><br><span class="line"><span class="comment">                  parameters为函数参数的地址，regs为远程进程call函数前的寄存器环境</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示call函数成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint32_t</span> ExecuteAddr, <span class="keyword">long</span> *parameters, <span class="keyword">long</span> num_params, struct pt_regs* regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// ARM处理器，函数传递参数，将前四个参数放到r0-r3，剩下的参数压入栈中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; i ++) &#123;    </span><br><span class="line">        regs-&gt;uregs[i] = parameters[i];    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_params) &#123;    </span><br><span class="line">        regs-&gt;ARM_sp -= (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>) ;    <span class="comment">// 分配栈空间，栈的方向是从高地址到低地址</span></span><br><span class="line">        <span class="keyword">if</span> (ptrace_writedata(pid, (<span class="keyword">void</span> *)regs-&gt;ARM_sp, (<span class="keyword">uint8_t</span> *)&amp;parameters[i], (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>))  == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    regs-&gt;ARM_pc = ExecuteAddr;           <span class="comment">//设置ARM_pc寄存器为需要调用的函数地址</span></span><br><span class="line">    <span class="comment">// 与BX跳转指令类似，判断跳转的地址位[0]是否为1，如果为1，则将CPST寄存器的标志T置位，解释为Thumb代码</span></span><br><span class="line">	<span class="comment">// 若为0，则将CPSR寄存器的标志T复位，解释为ARM代码</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;ARM_pc &amp; <span class="number">1</span>) &#123;    </span><br><span class="line">        <span class="comment">/* thumb */</span>    </span><br><span class="line">        regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);    </span><br><span class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">/* arm */</span>    </span><br><span class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    regs-&gt;ARM_lr = <span class="number">0</span>;        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span> || ptrace_continue(pid) == <span class="number">-1</span>) &#123;    </span><br><span class="line">        LOGD(<span class="string">"ptrace set regs or continue error, pid:%d"</span>, pid);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;  </span><br><span class="line">	<span class="comment">// 对于使用ptrace_cont运行的子进程，它会在3种情况下进入暂停状态：①下一次系统调用；②子进程退出；③子进程的执行发生错误。</span></span><br><span class="line">	<span class="comment">// 参数WUNTRACED表示当进程进入暂停状态后，立即返回</span></span><br><span class="line">	<span class="comment">// 将ARM_lr（存放返回地址）设置为0，会导致子进程执行发生错误，则子进程进入暂停状态</span></span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 判断是否成功执行函数</span></span><br><span class="line">    LOGD(<span class="string">"ptrace call ret status is %d\n"</span>, stat); </span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            LOGD(<span class="string">"ptrace call error"</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取远程进程的寄存器值，方便获取返回值</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(pid, regs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"After call getregs error"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    在指定进程中搜索对应模块的基址</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，若为-1表示自身进程，ModuleName表示要搜索的模块的名称</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示获取模块基址失败，返回非0为要搜索的模块基址</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">GetModuleBaseAddr</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span>* ModuleName)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">long</span> ModuleBaseAddr = <span class="number">0</span>; 	</span><br><span class="line">	<span class="keyword">char</span> *ModulePath, *MapFileLineItem;</span><br><span class="line">    <span class="keyword">char</span> szFileName[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">char</span> szMapFileLine[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> szProcessInfo[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 读取"/proc/pid/maps"可以获得该进程加载的模块</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        <span class="comment">//  枚举自身进程模块 </span></span><br><span class="line">        <span class="built_in">snprintf</span>(szFileName, <span class="keyword">sizeof</span>(szFileName), <span class="string">"/proc/self/maps"</span>);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="built_in">snprintf</span>(szFileName, <span class="keyword">sizeof</span>(szFileName), <span class="string">"/proc/%d/maps"</span>, pid);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    fp = fopen(szFileName, <span class="string">"r"</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) </span><br><span class="line">	&#123;    </span><br><span class="line">        <span class="keyword">while</span> (fgets(szMapFileLine, <span class="keyword">sizeof</span>(szMapFileLine), fp)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strstr</span>(szMapFileLine, ModuleName))</span><br><span class="line">			&#123;</span><br><span class="line">				MapFileLineItem = strtok(szMapFileLine, <span class="string">" \t"</span>); <span class="comment">// 基址信息</span></span><br><span class="line">                <span class="keyword">char</span> *Addr = strtok(szMapFileLine, <span class="string">"-"</span>);    </span><br><span class="line">                ModuleBaseAddr = strtoul(Addr, <span class="literal">NULL</span>, <span class="number">16</span> );    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (ModuleBaseAddr == <span class="number">0x8000</span>)    </span><br><span class="line">                    ModuleBaseAddr = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">break</span>;   				</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">        fclose(fp) ;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)ModuleBaseAddr;       </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    获取远程进程与本进程都加载的模块中函数的地址</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，ModuleName表示模块名称，LocalFuncAddr表示本地进程中该函数的地址</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回远程进程中对应函数的地址</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">GetRemoteFuncAddr</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *ModuleName, <span class="keyword">void</span> *LocalFuncAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *LocalModuleAddr, *RemoteModuleAddr, *RemoteFuncAddr;</span><br><span class="line">	</span><br><span class="line">	LocalModuleAddr = GetModuleBaseAddr(<span class="number">-1</span>, ModuleName);</span><br><span class="line">	RemoteModuleAddr = GetModuleBaseAddr(pid, ModuleName);</span><br><span class="line">	</span><br><span class="line">	RemoteFuncAddr = (<span class="keyword">void</span> *)((<span class="keyword">long</span>)LocalFuncAddr - (<span class="keyword">long</span>)LocalModuleAddr + (<span class="keyword">long</span>)RemoteModuleAddr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> RemoteFuncAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    通过远程直接调用dlopen\dlsym的方法ptrace注入so模块到远程进程中</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，LibPath为被远程注入的so模块路径，FunctionName为远程注入的模块后调用的函数</span></span><br><span class="line"><span class="comment">				  FuncParameter指向被远程调用函数的参数（若传递字符串，需要先将字符串写入到远程进程空间中），NumParameter为参数的个数</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示注入成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">inject_remote_process</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">char</span>* LibPath,<span class="keyword">char</span>* FunctionName,<span class="keyword">long</span>* FuncParameter ,<span class="keyword">long</span> NumParameter)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> iRet = <span class="number">-1</span>;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">CurrentRegs</span>,<span class="title">OriginalRegs</span>;</span>	<span class="comment">//备份原始寄存器</span></span><br><span class="line">  	<span class="keyword">void</span> *mmap_addr,*dlopen_addr,*dlsym_addr,*dlclose_addr,*dlerror_addr; </span><br><span class="line"> 	<span class="keyword">void</span> *RemoteMapMemoryAddr, *RemoteModuleAddr, *RemoteModuleFuncAddr; <span class="comment">//远程进程内存映射地址(保存调用参数)，模块地址, 远程函数地址</span></span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">long</span> parameters[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//1. attach到进程</span></span><br><span class="line"> 	<span class="keyword">if</span>(ptrace_attach(pid) == <span class="number">-1</span>)</span><br><span class="line"> 		<span class="keyword">return</span> iRet;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//2. 保存当前环境</span></span><br><span class="line"> 	<span class="keyword">if</span>(ptrace_getregs(pid,&amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		ptrace_detach(pid);</span><br><span class="line"> 		<span class="keyword">return</span> iRet;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">memcpy</span>(&amp;OriginalRegs,&amp;CurrentRegs,<span class="keyword">sizeof</span>(struct pt_regs));</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//3.获取远程mmap函数地址 </span></span><br><span class="line"> 	<span class="comment">//map()  creates a new mapping in the virtual address space of the calling process.</span></span><br><span class="line"> 	<span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"></span><br><span class="line"> 	mmap_addr = GetRemoteFuncAddr(pid,libc_path,(<span class="keyword">void</span>*)mmap);</span><br><span class="line"> 	LOGD(<span class="string">"[+]mmap RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)mmap_addr);</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">//4. 设置mmap函数参数</span></span><br><span class="line"></span><br><span class="line"> 	parameters[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"> 	parameters[<span class="number">1</span>] = <span class="number">0x1000</span>;</span><br><span class="line"> 	parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC; <span class="comment">//内存属性</span></span><br><span class="line"> 	parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE;		<span class="comment">//匿名映射</span></span><br><span class="line"> 	parameters[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line"> 	parameters[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span>(ptrace_call(pid , (<span class="keyword">long</span>)mmap_addr , parameters , <span class="number">6</span> , &amp;CurrentRegs))</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		LOGD(<span class="string">"Call Remote mmap Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	RemoteMapMemoryAddr = (<span class="keyword">void</span>*)ptrace_getret(&amp;CurrentRegs);	<span class="comment">//获取分配内存的起始地址</span></span><br><span class="line"> 	LOGD(<span class="string">"[+]Remote Process Map Memory Addr:0x%lx"</span>, (<span class="keyword">long</span>)RemoteMapMemoryAddr);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 分别获取dlopen、dlsym、dlclose等函数的地址</span></span><br><span class="line">	dlopen_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">	dlsym_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">	dlclose_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlclose);</span><br><span class="line">	dlerror_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlerror);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	LOGD(<span class="string">"[+]dlopen RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlopen_addr);</span><br><span class="line">	LOGD(<span class="string">"[+]dlsym RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlsym_addr);</span><br><span class="line">	LOGD(<span class="string">"[+]dlclose RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlclose_addr);</span><br><span class="line">	LOGD(<span class="string">"[+]dlerror RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlerror_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(ptrace_writedata(pid,RemoteMapMemoryAddr,LibPath,<span class="built_in">strlen</span>(LibPath)+<span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Write LibPath:%s to RemoteProcess error"</span>, LibPath);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loadlibrary</span></span><br><span class="line">	<span class="comment">// 设置dlopen的参数,返回值为模块加载的地址</span></span><br><span class="line">	<span class="comment">// void *dlopen(const char *filename, int flag);</span></span><br><span class="line">	parameters[<span class="number">0</span>] = (<span class="keyword">long</span>)RemoteMapMemoryAddr;</span><br><span class="line">	parameters[<span class="number">1</span>] = RTLD_NOW| RTLD_GLOBAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)dlopen_addr, parameters, <span class="number">2</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote dlopen Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RemoteModuleAddr为远程进程加载注入模块的地址</span></span><br><span class="line">	RemoteModuleAddr = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">	LOGD(<span class="string">"Remote Process load module Addr:0x%lx"</span>, (<span class="keyword">long</span>)RemoteModuleAddr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">long</span>)RemoteModuleAddr == <span class="number">0x0</span>)   <span class="comment">// dlopen 错误</span></span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"dlopen error"</span>);</span><br><span class="line">		<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)dlerror_addr, parameters, <span class="number">0</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LOGD(<span class="string">"Call Remote dlerror Func Failed"</span>);</span><br><span class="line">			ptrace_detach(pid);</span><br><span class="line">			<span class="keyword">return</span> iRet;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span> *Error = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">		<span class="keyword">char</span> LocalErrorInfo[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		ptrace_readdata(pid, Error, LocalErrorInfo, <span class="number">1024</span>);</span><br><span class="line">		LOGD(<span class="string">"dlopen error:%s"</span>, LocalErrorInfo);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将so库中需要调用的函数名称写入到远程进程内存空间中</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_writedata(pid, RemoteMapMemoryAddr + <span class="built_in">strlen</span>(LibPath) + <span class="number">2</span>, FunctionName, <span class="built_in">strlen</span>(FunctionName) + <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Write FunctionName:%s to RemoteProcess error"</span>, FunctionName);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//GetProcAddress</span></span><br><span class="line">	<span class="comment">// 设置dlsym的参数，返回值为远程进程内函数的地址</span></span><br><span class="line">	<span class="comment">// void *dlsym(void *handle, const char *symbol);</span></span><br><span class="line">	parameters[<span class="number">0</span>] = (<span class="keyword">long</span>)RemoteModuleAddr;</span><br><span class="line">	parameters[<span class="number">1</span>] = (<span class="keyword">long</span>)(RemoteMapMemoryAddr + <span class="built_in">strlen</span>(LibPath) + <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)dlsym_addr, parameters, <span class="number">2</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote dlsym Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RemoteModuleFuncAddr为远程进程空间内获取的函数地址</span></span><br><span class="line">	RemoteModuleFuncAddr = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">	LOGD(<span class="string">"[+]Remote Process ModuleFunc Addr:0x%lx"</span>, (<span class="keyword">long</span>)RemoteModuleFuncAddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call </span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)RemoteModuleFuncAddr, FuncParameter, NumParameter, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote injected Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_setregs(pid, &amp;OriginalRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Recover reges failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;		</span><br><span class="line">	&#125;</span><br><span class="line">	LOGD(<span class="string">"Recover Regs Success"</span>);</span><br><span class="line">	ptrace_getregs(pid, &amp;CurrentRegs);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;OriginalRegs, &amp;CurrentRegs, <span class="keyword">sizeof</span>(CurrentRegs)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Set Regs Error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Detach</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_detach(pid) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"ptrace detach failed"</span>);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">  FileName: main.c</span></span><br><span class="line"><span class="comment">  Description:       ptrace注入      </span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/user.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inject.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/PrintLog.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    通过进程名称定位到进程的PID</span></span><br><span class="line"><span class="comment">  Input:          process_name为要定位的进程名称</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回定位到的进程PID，若为-1，表示定位失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="keyword">pid_t</span> FindPidByProcessName(<span class="keyword">const</span> <span class="keyword">char</span> *process_name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ProcessDirID = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> filename[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> cmdline[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">entry</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( process_name == <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	DIR* dir = opendir( <span class="string">"/proc"</span> );</span><br><span class="line">	<span class="keyword">if</span> ( dir == <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>( (entry = readdir(dir)) != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		ProcessDirID = atoi( entry-&gt;d_name );</span><br><span class="line">		<span class="keyword">if</span> ( ProcessDirID != <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(filename, MAX_PATH, <span class="string">"/proc/%d/cmdline"</span>, ProcessDirID);</span><br><span class="line">			fp = fopen( filename, <span class="string">"r"</span> );</span><br><span class="line">			<span class="keyword">if</span> ( fp )</span><br><span class="line">			&#123;</span><br><span class="line">				fgets(cmdline, <span class="keyword">sizeof</span>(cmdline), fp);</span><br><span class="line">				fclose(fp);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">strncmp</span>(process_name, cmdline, <span class="built_in">strlen</span>(process_name)) == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					pid = ProcessDirID;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	closedir(dir);</span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> InjectModuleName[MAX_PATH] = <span class="string">"/data/libInjectModule.so"</span>;        <span class="comment">// 要注入模块全路径</span></span><br><span class="line">	<span class="keyword">char</span> RemoteCallFunc[MAX_PATH] = <span class="string">"Inject_entry"</span>;              	      <span class="comment">// 注入模块后调用模块函数名称</span></span><br><span class="line">	<span class="keyword">char</span> InjectProcessName[MAX_PATH] = <span class="string">"com.example.yllen.myapplication"</span>;  <span class="comment">// 注入进程名称</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当前设备环境判断</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> defined(__i386__)  </span></span><br><span class="line">	LOGD(<span class="string">"Current Environment x86"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">elif</span> defined(__arm__)</span></span><br><span class="line">	LOGD(<span class="string">"Current Environment ARM"</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span>     </span></span><br><span class="line">	LOGD(<span class="string">"other Environment"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pid_t</span> pid = FindPidByProcessName(InjectProcessName);</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Get Pid Failed"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"begin inject process, RemoteProcess pid:%d, InjectModuleName:%s, RemoteCallFunc:%s\n"</span>, pid, InjectModuleName, RemoteCallFunc);</span><br><span class="line">	<span class="keyword">int</span> iRet = inject_remote_process(pid,  InjectModuleName, RemoteCallFunc,  <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//int iRet = inject_remote_process_shellcode(pid,  InjectModuleName, RemoteCallFunc,  NULL, 0);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (iRet == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Inject Success\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Inject Failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"end inject,%d\n"</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android.mk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := inject</span><br><span class="line">LOCAL_SRC_FILES := inject.c main.c</span><br><span class="line"></span><br><span class="line">LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog</span><br><span class="line"></span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br></pre></td></tr></table></figure>

<p>参考Ref：<br>    1. <a href="http://gslab.qq.com/portal.php?mod=view&amp;aid=162" target="_blank" rel="noopener">http://gslab.qq.com/portal.php?mod=view&amp;aid=162</a></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2016/09/17/Elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">Elf文件格式学习</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2016-09-17</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="背-che-景-dan"><a href="#背-che-景-dan" class="headerlink" title="背(che)景(dan)"></a>背(che)景(dan)</h2><p>又到了每年的中秋节了，话说从大学开始，对于节日的回忆基本都停留在了学校中，尤其是大三开始，每逢节日都会窝在宿舍中学习一些东西，大三的清明节了解了下<code>缓冲区溢出</code>，大四的清明节，在准备面试，也在学一些东西，貌似是<code>Windows内核</code>啥的。ok，时间转到了大学最后一个学期，清明节忙着写毕设，Wow，终于毕业了，今年中秋搞点啥呢…Elf文件格式。</p>
<p>为什么学(了)习(解)这个呢？主要是渐渐觉得要去搞移动端安全相关了，所以该有些准备知识了，话说我java也不是菜鸡(虽然N久都没看，没用了)，但那又怎样，所以路线大致是Elf-&gt;Arm汇编-&gt;Dex(smail)-&gt;Apk-&gt;java(native)-&gt;android(hook、anti&amp;prot)-&gt;android(PWN!),这个路线有些扯淡，但目前就这么定了，后面再做<code>大</code>的调整，2333…</p>
<h2 id="正-yan-文-su"><a href="#正-yan-文-su" class="headerlink" title="正(yan)文(su)"></a>正(yan)文(su)</h2><h3 id="先说下文件对象："><a href="#先说下文件对象：" class="headerlink" title="先说下文件对象："></a>先说下文件对象：</h3><ol>
<li>可重定位的对象文件(Relocatable file)<br>类似于编译器生产的中间文件，在链接时使用。</li>
<li>可执行的对象文件(Executable file)<br>可以运行的文件，比如linux下的ls、vi编辑器等</li>
<li>可被共享的对象文件(Shared object file)<br>应用程序可以将公共函数放在一个文件中(.so)，这样在运行时动态导入，节省了很多磁盘空间</li>
</ol>
<h3 id="Elf文件格式提供了两种视图，一种是链接-文件-视图，一种是运行-内存-视图，"><a href="#Elf文件格式提供了两种视图，一种是链接-文件-视图，一种是运行-内存-视图，" class="headerlink" title="Elf文件格式提供了两种视图，一种是链接(文件)视图，一种是运行(内存)视图，"></a>Elf文件格式提供了两种视图，一种是<code>链接(文件)视图</code>，一种是<code>运行(内存)视图</code>，</h3><p><img src="./16-04-05.jpg" alt=""></p>
<p>上图左侧为链接视图，右侧为运行视图,其中主要区别在section(segment)上，以Android NDK中的helloWord jni程序编译的.so文件为例，使用readelf命令解析一下：<br>使用<code>readelf -S</code> 解析sections<br><img src="./16-07-33.jpg" alt=""><br>可以看到文件有19个section(段或者节)，其中.shstrtab是文件的字符串段，后面出现的关于字符串的字段的值都是在这个字段中的下标值。<br>使用<code>readelf --segments</code>解析运行视图</p>
<p><img src="./16-11-09.jpg" alt=""><br>现在段变成了6个，可以观察到这些段都是前面section中的项，也就是说elf文件在运行时有些相同属性的段被放在同一个段中。</p>
<h4 id="为什么要这么做呢？"><a href="#为什么要这么做呢？" class="headerlink" title="为什么要这么做呢？"></a>为什么要这么做呢？</h4><p>原因是目前的os大多都是以页为单位管理内存的，在linux中，典型的页大小的为4096b=4kb，所以即使一个大小不够4kb的数据，都必须分配一个4kb大小的内存，这样对于超多section的视图来说就是在浪费空间，所以linux将相同flg值以及相关属性的section放在一个segment中，方便权限管理，这样内存的浪费也就减小下来，所以从这里可以看出，segment是section的一个子集。</p>
<h3 id="Elf组织结构"><a href="#Elf组织结构" class="headerlink" title="Elf组织结构"></a>Elf组织结构</h3><p>Elf 文件的大体结构</p>
<blockquote>
<ol>
<li>Elf header 描述整个文件的组织</li>
<li>Elf program_header_table 描述文件的各种segment，用来告诉系/统如何创建进程映像(一个段 包含 1个或多个section)</li>
<li>Elf section_header_table 包含文件的各个section的信息</li>
</ol>
</blockquote>
<p>类型<br><img src="./16-23-04.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>	DWORD	Elf32_Addr;   </span><br><span class="line"><span class="keyword">typedef</span>	WORD	Elf32_Half;    </span><br><span class="line"><span class="keyword">typedef</span>	DWORD	Elf32_Off;    </span><br><span class="line"><span class="keyword">typedef</span>	DWORD	Elf32_Sword;  </span><br><span class="line"><span class="keyword">typedef</span>	DWORD	Elf32_Word;</span><br></pre></td></tr></table></figure>
<p>Elf header</p>
<p><img src="./16-26-53.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	e_ident[EI_NIDENT];</span><br><span class="line">	Elf32_Half		e_type;</span><br><span class="line">					<span class="comment">//	该成员确定该object的类型。</span></span><br><span class="line">					<span class="comment">//	Name        Value  Meaning</span></span><br><span class="line">					<span class="comment">//	====        =====  =======</span></span><br><span class="line">					<span class="comment">//	ET_NONE         0  No file type</span></span><br><span class="line">					<span class="comment">//	ET_REL          1  Relocatable file</span></span><br><span class="line">					<span class="comment">//	ET_EXEC         2  Executable file</span></span><br><span class="line">					<span class="comment">//	ET_DYN          3  Shared object file</span></span><br><span class="line">					<span class="comment">//	ET_CORE         4  Core file</span></span><br><span class="line">					<span class="comment">//	ET_LOPROC  0xff00  Processor-specific</span></span><br><span class="line">					<span class="comment">//	ET_HIPROC  0xffff  Processor-specific</span></span><br><span class="line">	</span><br><span class="line">	Elf32_Half		e_machine;</span><br><span class="line">					<span class="comment">//	该成员变量指出了运行该程序需要的体系结构。</span></span><br><span class="line">					<span class="comment">//	Name      Value  Meaning</span></span><br><span class="line">					<span class="comment">//	====      =====  =======</span></span><br><span class="line">					<span class="comment">//	EM_NONE       0  No machine</span></span><br><span class="line">					<span class="comment">//	EM_M32        1  AT&amp;T WE 32100</span></span><br><span class="line">					<span class="comment">//	EM_SPARC      2  SPARC</span></span><br><span class="line">					<span class="comment">//	EM_386        3  Intel 80386</span></span><br><span class="line">					<span class="comment">//	EM_68K        4  Motorola 68000</span></span><br><span class="line">					<span class="comment">//	EM_88K        5  Motorola 88000</span></span><br><span class="line">					<span class="comment">//	EM_860        7  Intel 80860</span></span><br><span class="line">					<span class="comment">//	EM_MIPS       8  MIPS RS3000</span></span><br><span class="line"></span><br><span class="line">	Elf32_Word		e_version;</span><br><span class="line">					<span class="comment">//	这个成员确定object文件的版本。</span></span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					<span class="comment">//	Name         Value  Meaning</span></span><br><span class="line">					<span class="comment">//	====         =====  =======</span></span><br><span class="line">					<span class="comment">//	EV_NONE          0  Invalid version</span></span><br><span class="line">					<span class="comment">//	EV_CURRENT       1  Current version</span></span><br><span class="line">	Elf32_Addr		e_entry;</span><br><span class="line">					<span class="comment">//	OEP;</span></span><br><span class="line">					<span class="comment">//	假如文件没有如何关联的入口点，该成员就保持为 0。</span></span><br><span class="line">	Elf32_Off		e_phoff;</span><br><span class="line">					<span class="comment">//	该成员保持着程序头表（program header table）在文件中的偏移量(以字节计数)。 same as NT HEADER</span></span><br><span class="line">					<span class="comment">//	假如该文件没有程序头表的的话，该成员就保持为 0。</span></span><br><span class="line">	Elf32_Off		e_shoff;</span><br><span class="line">					<span class="comment">//	该成员保持着程序头表（section header table）在文件中的偏移量(以字节计数)。 same as NT HEADER</span></span><br><span class="line">					<span class="comment">//	假如该文件没有程序头表的的话，该成员就保持为 0。</span></span><br><span class="line">	Elf32_Word		e_flags;</span><br><span class="line">					<span class="comment">//	该成员保存着相关文件的特定处理器标志。</span></span><br><span class="line">					<span class="comment">//	flag的名字来自于EF_&lt;machine&gt;_&lt;flag&gt;。看下机器信息“Machine Information”部分的flag的定义。</span></span><br><span class="line">	Elf32_Half		e_ehsize;</span><br><span class="line">					<span class="comment">//该成员保存着ELF头大小(以字节计数)。</span></span><br><span class="line">	Elf32_Half		e_phentsize;</span><br><span class="line">					<span class="comment">//	该成员保存着在文件的程序头表（program header table）中一个入口的大小</span></span><br><span class="line">					<span class="comment">//	(以字节计数)。所有的入口都是同样的大小。</span></span><br><span class="line">	Elf32_Half		e_e_phnum;</span><br><span class="line">					<span class="comment">//	该成员保存着在程序头表中入口的个数。</span></span><br><span class="line">					<span class="comment">//	因此，e_phentsize和e_phnum的乘机就是表的大小(以字节计数).</span></span><br><span class="line">					<span class="comment">//	假如没有程序头表（program header table），e_phnum变量为0。</span></span><br><span class="line">	Elf32_Half		e_shentsize;</span><br><span class="line">					<span class="comment">//	该成员保存着section头的大小(以字节计数)。</span></span><br><span class="line">					<span class="comment">//	一个section头是在section头表(section header table)的一个入口；</span></span><br><span class="line">					<span class="comment">//	所有的入口都是同样的大小。</span></span><br><span class="line">	Elf32_Half		e_shnum;</span><br><span class="line">					<span class="comment">//	该成员保存着在section header table中的入口数目。</span></span><br><span class="line">					<span class="comment">//	因此，e_shentsize和e_shnum的乘积就是section头表的大小(以字节计数)。</span></span><br><span class="line">					<span class="comment">//	假如文件没有section头表，e_shnum值为0。</span></span><br><span class="line">	Elf32_Half		e_shstrndx;</span><br><span class="line">					<span class="comment">//	该成员保存着跟section名字字符表相关入口的section头表(section header table)索引。</span></span><br><span class="line">					<span class="comment">//	假如文件中没有section名字字符表，该变量值为SHN_UNDEF。</span></span><br><span class="line">					<span class="comment">//	更详细的信息 看下面“Sections”和字符串表(“String Table”) 。</span></span><br><span class="line"></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p><img src="./16-27-48.jpg" alt=""><br>program header</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Elf32_Word		p_type;</span><br><span class="line">					<span class="comment">//	Name             Value</span></span><br><span class="line">					<span class="comment">//	====             =====</span></span><br><span class="line">					<span class="comment">//	PT_NULL              0</span></span><br><span class="line">					<span class="comment">//	PT_LOAD              1</span></span><br><span class="line">					<span class="comment">//	PT_DYNAMIC           2</span></span><br><span class="line">					<span class="comment">//	PT_INTERP            3</span></span><br><span class="line">					<span class="comment">//	PT_NOTE              4</span></span><br><span class="line">					<span class="comment">//	PT_SHLIB             5</span></span><br><span class="line">					<span class="comment">//	PT_PHDR              6</span></span><br><span class="line">					<span class="comment">//	PT_LOPROC   0x70000000</span></span><br><span class="line">					<span class="comment">//	PT_HIPROC   0x7fffffff</span></span><br><span class="line">	Elf32_Off		p_offset; </span><br><span class="line">					<span class="comment">//	该成员给出了该段的驻留位置相对于文件开始处的偏移。 offset file</span></span><br><span class="line">	Elf32_Off		p_vadrr;</span><br><span class="line">					<span class="comment">//	该成员给出了该段在内存中的首字节地址。   rva</span></span><br><span class="line">	Elf32_Addr		p_paddr;</span><br><span class="line">					</span><br><span class="line">	Elf32_Word		p_filesz;</span><br><span class="line">					<span class="comment">//	文件映像中该段的字节数；它可能是 0 。</span></span><br><span class="line">	Elf32_Word		p_memsz;</span><br><span class="line">					<span class="comment">//	内存映像中该段的字节数；它可能是 0 。</span></span><br><span class="line">	Elf32_Word		p_flags;</span><br><span class="line">	Elf32_Word		p_align;</span><br><span class="line">					<span class="comment">//	该成员给出了该段在内存和文件中排列值。</span></span><br><span class="line">					<span class="comment">//	0 和 1 表示不需要排列。否则， p_align 必须为正的 2 的幂，</span></span><br><span class="line">					<span class="comment">//	并且 p_vaddr 应当等于 p_offset 模 p_align 。</span></span><br><span class="line">&#125;Elf32_Phdr;</span><br></pre></td></tr></table></figure>
<p>section header</p>
<p><img src="./16-28-14.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">	Elf32_Word		sh_name;</span><br><span class="line">					<span class="comment">//	该成员指定了这个section的名字。</span></span><br><span class="line">					<span class="comment">//	它的值是section报头字符表section的索引。[看以下的“String Table”], 以NULL空字符结束。</span></span><br><span class="line">	Elf32_Word		sh_type;</span><br><span class="line">					<span class="comment">//	Section Types, sh_type</span></span><br><span class="line">					<span class="comment">//	---------------------------</span></span><br><span class="line">					<span class="comment">//	Name                 Value    Description</span></span><br><span class="line">					<span class="comment">//	====                 =====    ===========</span></span><br><span class="line">					<span class="comment">//	SHT_NULL				 0    该值表明该section头是无效的；它没有相关的section。</span></span><br><span class="line">					<span class="comment">//	SHT_PROGBITS			 1    该section保存被程序定义了的一些信息，它的格式和意义取决于程序本身。</span></span><br><span class="line">					<span class="comment">//	SHT_SYMTAB				 2    该sections保存着一个符号表（symbol table）。</span></span><br><span class="line">					<span class="comment">//	SHT_STRTAB				 3    该section保存着一个字符串表。</span></span><br><span class="line">					<span class="comment">//	SHT_RELA				 4    该section保存着具有明确加数的重定位入口。</span></span><br><span class="line">					<span class="comment">//	SHT_HASH				 5    该标号保存着一个标号的哈希(hash)表。</span></span><br><span class="line">					<span class="comment">//	SHT_DYNAMIC				 6    该section保存着动态连接的信息。</span></span><br><span class="line">					<span class="comment">//	SHT_NOTE				 7    该section保存着其他的一些标志文件的信息。</span></span><br><span class="line">					<span class="comment">//	SHT_NOBITS				 8    该类型的section在文件中不占空间，但是类似SHT_PROGBITS。</span></span><br><span class="line">					<span class="comment">//	SHT_REL					 9    该section保存着重定位的入口。</span></span><br><span class="line">					<span class="comment">//	SHT_SHLIB				10    该section类型保留但语意没有指明。包含这个类型的section的程序是不符合ABI的。</span></span><br><span class="line">					<span class="comment">//	SHT_DYNSYM				11    该sections保存着一个符号表（symbol table）。</span></span><br><span class="line">					<span class="comment">//	SHT_LOPROC		0x70000000    在这范围之间的值为特定处理器语意保留的。</span></span><br><span class="line">					<span class="comment">//	SHT_HIPROC		0x7fffffff    在这范围之间的值为特定处理器语意保留的。</span></span><br><span class="line">					<span class="comment">//	SHT_LOUSER		0x80000000    该变量为应用程序保留的索引范围的最小边界。</span></span><br><span class="line">					<span class="comment">//	SHT_HIUSER		0xffffffff    该变量为应用程序保留的索引范围的最大边界。</span></span><br><span class="line">	Elf32_Word		sh_flags;</span><br><span class="line">					<span class="comment">//	Section Attribute Flags, sh_flags</span></span><br><span class="line">					<span class="comment">//	-----------------------------------		</span></span><br><span class="line">					<span class="comment">//	Name                Value    Description</span></span><br><span class="line">					<span class="comment">//	====                =====    ===========</span></span><br><span class="line">					<span class="comment">//	SHF_WRITE             0x1    该section包含了在进程执行过程中可被写的数据。</span></span><br><span class="line">					<span class="comment">//	SHF_ALLOC             0x2    该section在进程执行过程中占据着内存。</span></span><br><span class="line">					<span class="comment">//	SHF_EXECINSTR         0x4    该section包含了可执行的机器指令。</span></span><br><span class="line">					<span class="comment">//	SHF_MASKPROC   0xf0000000    所有的包括在这掩码中的位为特定处理语意保留的。</span></span><br><span class="line">	Elf32_Addr		sh_addr;</span><br><span class="line">					<span class="comment">//	假如该section将出现在进程的内存映象空间里，该成员给出了一个该section在内存中的位置。否则，该变量为0。</span></span><br><span class="line">	Elf32_Off		sh_offset;</span><br><span class="line">					<span class="comment">//	该成员变量给出了该section的字节偏移量(从文件开始计数)。</span></span><br><span class="line">	Elf32_Word		sh_size;</span><br><span class="line">					<span class="comment">//	该成员给你了section的字节大小。</span></span><br><span class="line">	Elf32_Word		sh_link;</span><br><span class="line">					<span class="comment">//	该成员保存了一个section报头表的索引连接，它的解释依靠该section的类型。</span></span><br><span class="line">					<span class="comment">//	更多信息参见表"sh_link and sh_info Interpretation"</span></span><br><span class="line">	Elf32_Word		sh_info;</span><br><span class="line">					<span class="comment">//	该成员保存着额外的信息，它的解释依靠该section的类型。</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">//	sh_link and sh_info Interpretation</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">//	-------------------------------------------------------------------------------</span></span><br><span class="line">					<span class="comment">//	sh_type        sh_link                          sh_info</span></span><br><span class="line">					<span class="comment">//	=======        =======                          =======</span></span><br><span class="line">					<span class="comment">//	SHT_DYNAMIC    The section header index of      0</span></span><br><span class="line">					<span class="comment">//	               the string table used by</span></span><br><span class="line">					<span class="comment">//	               entries in the section.</span></span><br><span class="line">					<span class="comment">//	-------------------------------------------------------------------------------</span></span><br><span class="line">					<span class="comment">//	SHT_HASH       The section header index of      0</span></span><br><span class="line">					<span class="comment">//	               the symbol table to which the</span></span><br><span class="line">					<span class="comment">//	               hash table applies.</span></span><br><span class="line">					<span class="comment">//	-------------------------------------------------------------------------------</span></span><br><span class="line">					<span class="comment">//	SHT_REL        The section header index of      The section header index of</span></span><br><span class="line">					<span class="comment">//	SHT_RELA       the associated symbol table.     the section to which the</span></span><br><span class="line">					<span class="comment">//	                                                relocation applies.</span></span><br><span class="line">					<span class="comment">//	-------------------------------------------------------------------------------</span></span><br><span class="line">					<span class="comment">//	SHT_SYMTAB     The section header index of      One greater than the symbol</span></span><br><span class="line">					<span class="comment">//	-------------------------------------------------------------------------------</span></span><br><span class="line">					<span class="comment">//	SHT_DYNSYM     the associated string table.     table index of the last local</span></span><br><span class="line">					<span class="comment">//	               symbol (binding STB_LOCAL).</span></span><br><span class="line">					<span class="comment">//	-------------------------------------------------------------------------------</span></span><br><span class="line">					<span class="comment">//	other          SHN_UNDEF                        0</span></span><br><span class="line">					<span class="comment">//	-------------------------------------------------------------------------------</span></span><br><span class="line">	Elf32_Word		sh_addralign;</span><br><span class="line">					<span class="comment">//	一些sections有地址对齐的约束。</span></span><br><span class="line">	Elf32_Word		sh_entsize;</span><br><span class="line">					<span class="comment">//	一些sections保存着一张固定大小入口的表，就象符号表。</span></span><br><span class="line">					<span class="comment">//	对于这样一个section来说，该成员给出了每个入口的字节大小。</span></span><br><span class="line">					<span class="comment">//	如果该section没有保存着一张固定大小入口的表，该成员就为0。</span></span><br><span class="line"></span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<p>###关键段(符号表、重定位表、GOT表)<br>####符号表(.dynsym)<br>描述了用来定位、重定位程序中所有的符号定义以及引用的信息，符号指的是经过修饰了的函数名或者变量名，修饰方法由编译器制定。<br><code>010编辑器中Elf解析模板</code><br><img src="./16-48-08.jpg" alt=""><br>符号表的组织结构： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">     Elf32_Word st_name;      <span class="comment">//符号表项名称。如果该值非0，则表示符号名的字</span></span><br><span class="line">                                     <span class="comment">//符串表索引(offset)，否则符号表项没有名称。</span></span><br><span class="line">     Elf32_Addr st_value;       <span class="comment">//符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span></span><br><span class="line">     Elf32_Word st_size;         <span class="comment">//符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;     <span class="comment">//符号的类型和绑定属性。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;    <span class="comment">//未定义。</span></span><br><span class="line">     Elf32_Half st_shndx;        <span class="comment">//每个符号表项都以和其他节区的关系的方式给出定义。</span></span><br><span class="line">　　　　　　　　　　　　　<span class="comment">//此成员给出相关的节区头部表索引。</span></span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>
<p>####字符串(.dynstr)<br>段描述<br><img src="./16-56-19.jpg" alt=""><br>内容</p>
<p><img src="./16-58-43.jpg" alt=""><br>其组织形式与符号表相同<br>###重定位表<br>程序经过编辑器-&gt;编译器-&gt;链接器步骤之后，并不能直接去运行，因为很多情况之下编译器是将程序从0地址开始做为基址的，当加载到内存的基地址发生变化后，原来静态计算的变量、函数地址都发生了变化，导致程序不能继续执行，或者.so文件在被加载到一个被占用的基地址时，需要重新加载到其他空闲地址，这样也要涉及到重定位，简单来说，重定位就是将程序运行所需要的函数、变量地址都关联到实际内存地址。<br>重定位表的格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    Elf32_Addr r_offset;     <span class="comment">//重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span></span><br><span class="line">    Elf32_Word r_info;       <span class="comment">//要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span></span><br><span class="line">                              <span class="comment">//其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>重定位段：<br><img src="./17-06-53.jpg" alt=""></p>
<p><em>未完待续……</em></p>
<p>Ref:</p>
<ol>
<li><a href="http://blog.csdn.net/feglass/article/details/51469511" target="_blank" rel="noopener">http://blog.csdn.net/feglass/article/details/51469511</a></li>
</ol>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2015/10/03/%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/">主动防御技术浅析</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2015-10-03</span>
                
            </div>
            <div class="post-content">
                
                    <p>杀毒软件为了能实时检测到系统中任何变化，并进一步进行判断该操作是否存在危害，均采用挂钩系统关键调用方式实现该流程，该技术称为主动防御技术。</p>
<p>功能方面（检测和保护）有如下方面</p>
<blockquote>
<p>比如监控文件变化、监控注册表变化、监控内存加载、监控进程\线程变化、实现自身进程保护、实现自身窗体保护、安全输入等。 </p>
</blockquote>
<p>涉及到的关键系统服务表 SSDT 、Shadow SSDT，为了更好的兼容性，一般不会直接去替换服务表中例程，而选择挂钩 KiFastCallEntry，好处有很多，至少可以自己重载一份关键系统例程，防止被在前面拦截掉。</p>
<p>实现时需要保证能在ring3下获取到ring0拦截到的信息，并且做出判断返回给ring0程序，继续执行下面的操作，也即保证ring3 、 ring0 程序同步。</p>
<p>采用方案如下：</p>
<p>&nbsp;</p>
<blockquote>
<p>1  ring3程序CreateEvent 两个事件( E1 、E2)，把句柄发送给ring0</p>
<p>2  ring0程序调用 ObReferenceObjectByHandle 获取到事件对象</p>
<p>3  ring3程序创建一个线程在里面 WaitForSingleObject ( E1 )</p>
<p>4  ring0程序拦截到一次调用，SetEvent( E1 )，此时 ring3 程序继续执行</p>
<p>ring0程序 KeWaitForSingleObject( E2 )</p>
<p>5  ring3程序进行判断该请求，将信息发给ring0 ，并SetEvent( E2 )</p>
<p>6  ring0 已经有信息了，可以继续执行。<br>&nbsp;</p>
</blockquote>
<p><img src="http://imglf0.ph.126.net/8XleipQpSANzRgQzrvhgew==/6631360235792791920.png" alt=""></p>
<p><strong>最后</strong></p>
<blockquote>
<p>本程序未挂钩KifastCallEntry 以及 HOOK 任何函数，只是一个小的demo，里面用到</p>
<p>CreateProcessNotifyFunction来实现拦截进程创建信息，后续如是要扩展，挂钩KifastCallEntry, Inline HOOK 某些API，封装事件消息，并设置一个队列来存放，依次反馈给ring3，并实现一个黑、白名单机制。<br>&nbsp;</p>
</blockquote>
<p><strong>代码：</strong></p>
<p>这里给一个简单 DEMO 关键代码：</p>
<p>驱动部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ntddk.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIOCTL_TYPE FILE_DEVICE_UNKNOWN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_START \</span></span><br><span class="line"></span><br><span class="line">CTL_CODE( SIOCTL_TYPE, <span class="number">0x901</span>, METHOD_BUFFERED, FILE_ANY_ACCESS )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_STOP \</span></span><br><span class="line"></span><br><span class="line">CTL_CODE( SIOCTL_TYPE, <span class="number">0x902</span>, METHOD_BUFFERED, FILE_ANY_ACCESS )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_GET_DATA \</span></span><br><span class="line"></span><br><span class="line">CTL_CODE( SIOCTL_TYPE, <span class="number">0x903</span>, METHOD_BUFFERED, FILE_ANY_ACCESS )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_SET_REPLY	\</span></span><br><span class="line"></span><br><span class="line">CTL_CODE( SIOCTL_TYPE, <span class="number">0x904</span>, METHOD_BUFFERED, FILE_ANY_ACCESS )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVERNAMEL <span class="meta-string">"\\Device\\KernelHandle"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYMBOLICNAMEL <span class="meta-string">"\\DosDevices\\KernelHandle"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G_EVENTL <span class="meta-string">"\\BaseNamedObjects\\MyEvent"</span> <span class="comment">/* 应用层 触发 */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSINFO</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ULONGPID;</span><br><span class="line"></span><br><span class="line">	charname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	charPATH[<span class="number">256</span>];</span><br><span class="line">&#125;PROCERSSINFO, *PPROCESSINFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLEINFO</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HANDLEarg1;     <span class="comment">/* 这个是 内核层 SET */</span></span><br><span class="line"></span><br><span class="line">	HANDLEarg2;     <span class="comment">/* 这个是 应用层 SET */</span></span><br><span class="line">&#125;HANDLEINFO, *PHANDLEINFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec( dllimport )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS NTAPI</span><br><span class="line"></span><br><span class="line">ZwTerminateProcess( IN HANDLE ProcessHandle OPTIONAL,</span><br><span class="line"></span><br><span class="line">		    IN NTSTATUS ExitStatus );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line"></span><br><span class="line">PsLookupProcessByProcessId(</span><br><span class="line"></span><br><span class="line">	IN HANDLE ProcessId,</span><br><span class="line"></span><br><span class="line">	OUT PEPROCESS *<span class="built_in">Process</span></span><br><span class="line"></span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zhudongfangyu.h"</span></span></span><br><span class="line"></span><br><span class="line">BOOLEAN g_bIsNotifyRoutineSetted;</span><br><span class="line"></span><br><span class="line">PKEVENT g_pEventObject0 = <span class="literal">NULL</span>;         <span class="comment">/* 内核层触发 */</span></span><br><span class="line"></span><br><span class="line">PKEVENT g_pEventObject3 = <span class="literal">NULL</span>;         <span class="comment">/* 应用层触发 */</span></span><br><span class="line"></span><br><span class="line">HANDLEg_hEvent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOLEANg_bREPLY;</span><br><span class="line"></span><br><span class="line">UNICODE_STRINGEventName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OBJECT_HANDLE_INFORMATION g_ObjectHandleInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">PrintIrpInfo</span><span class="params">( PIRP Irp )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">MyUnload</span><span class="params">( PDRIVER_OBJECT pDerverObject )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PDEVICE_OBJECTdevObj = pDerverObject-&gt;DeviceObject;</span><br><span class="line"></span><br><span class="line">	UNICODE_STRINGsymbolicName;</span><br><span class="line"></span><br><span class="line">	RtlInitUnicodeString( &amp;symbolicName, SYMBOLICNAME );</span><br><span class="line"></span><br><span class="line">	IoDeleteSymbolicLink( &amp;symbolicName );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( devObj != <span class="literal">NULL</span> )</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice( devObj );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DbgPrint( <span class="string">"MyUnload"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SioctlCreateClose</span><span class="params">( PDEVICE_OBJECT DeviceObject, PIRP irp )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	IoCompleteRequest( irp, IO_NO_INCREMENT );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PID信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CHAR g_szPIDInfo[20];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PROCERSSINFO pi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">CreateProcessNotifyFunction</span><span class="params">( IN HANDLE hParentId, IN HANDLE hProcessId, IN BOOLEAN bCreate )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PEPROCESSlProcess;</span><br><span class="line"></span><br><span class="line">	ANSI_STRINGExePath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*POBJECT_NAME_INFORMATION ExePath;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果是进程创建 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( bCreate )</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		PsLookupProcessByProcessId( hProcessId, &amp;lProcess );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 格式化字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RtlZeroMemory(g_szPIDInfo, 20);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RtlStringCchPrintfA(g_szPIDInfo, 20, "%d", (int)hProcessId);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		GetProcPath( hProcessId, &amp;ExePath );</span><br><span class="line"></span><br><span class="line">		RtlCopyBytes( (PVOID) pi.name, (PVOID) ( (<span class="keyword">char</span> *) lProcess + <span class="number">0x16c</span>), <span class="number">15</span> );</span><br><span class="line"></span><br><span class="line">		RtlCopyBytes( pi.PATH, ExePath.Buffer, ExePath.Length );</span><br><span class="line"></span><br><span class="line">		pi.PID = hProcessId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">" %s"</span>, pi.name );</span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">"%s"</span>, pi.PATH );</span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">"%x"</span>, pi.PID );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*RtlStringCchPrintfA( pi.PATH, ExePath-&gt;Length, "%s" , ExePath-&gt;Buffer ); */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件为有信号，通知应用层  接收 数据 */</span></span><br><span class="line"></span><br><span class="line">		KeSetEvent( g_pEventObject0, <span class="number">0</span>, FALSE );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待应用层确认。。 */</span></span><br><span class="line"></span><br><span class="line">		KeClearEvent( g_pEventObject3 );</span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">"-- Ring3 应该 反馈 --"</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		KeWaitForSingleObject( g_pEventObject3, Executive, KernelMode, FALSE, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">"-- RIng3 来了反馈--"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( g_bREPLY != TRUE )</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			DbgPrint( <span class="string">"-- Ring3 决定结束进程 --"</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * .... 其他操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">"-- Ring3 决定 放行 --"</span> );</span><br><span class="line"></span><br><span class="line">		KeClearEvent( g_pEventObject3 );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SioctlDeviceControl</span><span class="params">( PDEVICE_OBJECT DeviceObject, PIRP irp )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIO_STACK_LOCATIONirpSp;</span><br><span class="line"></span><br><span class="line">	ULONGinputBuffLength;</span><br><span class="line"></span><br><span class="line">	NTSTATUSstatus = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	PCHARinBuf, outBuf;</span><br><span class="line"></span><br><span class="line">	PCHARbuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ULONGOutputBuffLength;</span><br><span class="line"></span><br><span class="line">	HANDLEINFOhi;</span><br><span class="line"></span><br><span class="line">	irpSp = IoGetCurrentIrpStackLocation( irp );</span><br><span class="line"></span><br><span class="line">	inputBuffLength = irpSp-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"></span><br><span class="line">	OutputBuffLength = irpSp-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	inBuf = (PCHAR) irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line"></span><br><span class="line">	outBuf = (PCHAR) irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      DbgPrint("-- SioctlDeviceControl --");</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      PrintIrpInfo(irp);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      DbgPrint("-- 1 --");</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      DbgPrint("IOCTL_START : %x ",IOCTL_START);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if(!inputBuffLength || ! OutputBuffLength)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * status = STATUS_INVALID_PARAMETER;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * goto END;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      DbgPrint("-- 2 --");</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      DbgPrint("IOCTL_START : %x ",IOCTL_START);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> ( irpSp-&gt;Parameters.DeviceIoControl.IoControlCode )</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> IOCTL_START:</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint( <span class="string">" -- START --"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 取得句柄对象 */</span></span><br><span class="line"></span><br><span class="line">		hi = *(PHANDLEINFO ) inBuf;</span><br><span class="line"></span><br><span class="line">		status = ObReferenceObjectByHandle( hi.arg1, \</span><br><span class="line"></span><br><span class="line">						    GENERIC_ALL, <span class="literal">NULL</span>, KernelMode, (PVOID *) &amp;g_pEventObject0, &amp;g_ObjectHandleInfo );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		status = ObReferenceObjectByHandle( hi.arg2, \</span><br><span class="line"></span><br><span class="line">						    GENERIC_ALL, <span class="literal">NULL</span>, KernelMode, (PVOID *) &amp;g_pEventObject3, &amp;g_ObjectHandleInfo );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		KdPrint( (<span class="string">"g_pEventObject0 = 0x%X , g_pEventObject3 = 0x%X\n"</span>, g_pEventObject0, g_pEventObject3) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( !g_bIsNotifyRoutineSetted )</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			PsSetCreateProcessNotifyRoutine( CreateProcessNotifyFunction, FALSE );</span><br><span class="line"></span><br><span class="line">			g_bIsNotifyRoutineSetted = TRUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IOCTL_STOP:</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint( <span class="string">" -- STOP --"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( g_bIsNotifyRoutineSetted )</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">/* 移除进程创建通知函数 */</span></span><br><span class="line"></span><br><span class="line">			PsSetCreateProcessNotifyRoutine( CreateProcessNotifyFunction, TRUE );</span><br><span class="line"></span><br><span class="line">			g_bIsNotifyRoutineSetted = FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放对象引用 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( g_pEventObject0 != <span class="literal">NULL</span> )</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			ObDereferenceObject( g_pEventObject0 );</span><br><span class="line"></span><br><span class="line">			g_pEventObject0 = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( g_pEventObject3 != <span class="literal">NULL</span> )</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			ObDereferenceObject( g_pEventObject3 );</span><br><span class="line"></span><br><span class="line">			g_pEventObject3 = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IOCTL_GET_DATA:</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		ULONG nLength = <span class="keyword">sizeof</span>(pi);</span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">" -- GET_DATA --"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( outBuf == <span class="literal">NULL</span> &amp;&amp; (OutputBuffLength &lt; nLength) )</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			KdPrint( (<span class="string">"OutputBufferSize is too small ~!\n"</span>) );</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*复制进程PID到输出缓冲区 */</span></span><br><span class="line"></span><br><span class="line">		RtlCopyBytes( (PCHAR) outBuf, (PVOID) &amp;pi, nLength );</span><br><span class="line"></span><br><span class="line">		OutputBuffLength = nLength;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IOCTL_SET_REPLY:</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		RtlCopyBytes( (PVOID) &amp;g_bREPLY, inBuf, inputBuffLength ); <span class="comment">/* 1 字节 */</span></span><br><span class="line"></span><br><span class="line">		DbgPrint( <span class="string">"IOCTL_SET_REPLY: %d "</span>, g_bREPLY );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"></span><br><span class="line">	irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	irp-&gt;IoStatus.Information = OutputBuffLength;</span><br><span class="line"></span><br><span class="line">	IoCompleteRequest( irp, IO_NO_INCREMENT );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">( PDRIVER_OBJECT pDriverObject, PUNICODE_STRING RegPath )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	UNICODE_STRING DriverName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	UNICODE_STRING symbolicName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PDEVICE_OBJECT deviceObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RtlInitUnicodeString( &amp;DriverName, DRIVERNAME );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RtlInitUnicodeString( &amp;symbolicName, SYMBOLICNAME );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DbgPrint( <span class="string">"DriverEntry"</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RtlInitUnicodeString(&amp;EventName, G_EVENT); */</span></span><br><span class="line"></span><br><span class="line">	status = IoCreateDevice(</span><br><span class="line"></span><br><span class="line">		pDriverObject,          <span class="comment">/* Our Driver Object */</span></span><br><span class="line"></span><br><span class="line">		<span class="number">0</span>,                      <span class="comment">/* We don't use a device extension */</span></span><br><span class="line"></span><br><span class="line">		&amp;DriverName,            <span class="comment">/* Device name "\Device\SIOCTL" */</span></span><br><span class="line"></span><br><span class="line">		FILE_DEVICE_UNKNOWN,    <span class="comment">/* Device type */</span></span><br><span class="line"></span><br><span class="line">		<span class="number">0</span>,                      <span class="comment">/* Device characteristics */</span></span><br><span class="line"></span><br><span class="line">		TRUE,                   <span class="comment">/* Not an exclusive device */</span></span><br><span class="line"></span><br><span class="line">		&amp;deviceObject );        <span class="comment">/* Returned ptr to Device Object */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS( status ) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint( (<span class="string">"Couldn't create the device object %x \n"</span>), status );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>(status);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_bIsNotifyRoutineSetted = FALSE;</span><br><span class="line"></span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = SioctlCreateClose;</span><br><span class="line"></span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = SioctlCreateClose;</span><br><span class="line"></span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = SioctlDeviceControl;</span><br><span class="line"></span><br><span class="line">	pDriverObject-&gt;DriverUnload = MyUnload;</span><br><span class="line"></span><br><span class="line">	status = IoCreateSymbolicLink( &amp;symbolicName, &amp;DriverName );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS( status ) )</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint( (<span class="string">"Couldn't create the symboliclink \n"</span>) );</span><br><span class="line"></span><br><span class="line">		IoDeleteDevice( deviceObject );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>(status);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line">PrintIrpInfo(</span><br><span class="line">	PIRP Irp )</span><br><span class="line">&#123;</span><br><span class="line">	PIO_STACK_LOCATION irpSp;</span><br><span class="line">	irpSp = IoGetCurrentIrpStackLocation( Irp );</span><br><span class="line">	PAGED_CODE();</span><br><span class="line">	DbgPrint( <span class="string">"\tIrp-&gt;AssociatedIrp.SystemBuffer = 0x%p\n"</span>,Irp-&gt;AssociatedIrp.SystemBuffer );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DbgPrint( <span class="string">"\tIrp-&gt;UserBuffer = 0x%p\n"</span>, Irp-&gt;UserBuffer );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DbgPrint( <span class="string">"\tirpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer = 0x%p\n"</span>,irpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DbgPrint( <span class="string">"\tirpSp-&gt;Parameters.DeviceIoControl.InputBufferLength = %d\n"</span>,irpSp-&gt;Parameters.DeviceIoControl.InputBufferLength );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DbgPrint( <span class="string">"\tirpSp-&gt;Parameters.DeviceIoControl.OutputBufferLength = %d\n"</span>,irpSp-&gt;Parameters.DeviceIoControl.OutputBufferLength );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DbgPrint( <span class="string">"\t irpSp-&gt;Parameters.DeviceIoControl.IoControlCode  = %x\n"</span>,</span><br><span class="line"> irpSp-&gt;Parameters.DeviceIoControl.IoControlCode );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>APP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSINFO</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ULONGPID;</span><br><span class="line"></span><br><span class="line">	charname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	charPATH[<span class="number">256</span>];</span><br><span class="line">&#125;PROCERSSINFO, *PPROCESSINFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLEINFO</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HANDLEarg1;     <span class="comment">/* 这个是 内核层 SET */</span></span><br><span class="line"></span><br><span class="line">	HANDLEarg2;     <span class="comment">/* 这个是 应用层 SET */</span></span><br><span class="line">&#125;HANDLEINFO, *PHANDLEINFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局事件 */</span></span><br><span class="line"></span><br><span class="line">HANDLE g_EventHandle;</span><br><span class="line"></span><br><span class="line">HANDLE g_hkEvent; <span class="comment">/* 内核层句柄 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_bIsRunnig;</span><br></pre></td></tr></table></figure>
<p>start函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD dwRet;</span><br><span class="line"></span><br><span class="line">HANDLEINFO hi ;</span><br><span class="line"></span><br><span class="line">hi.arg1 = g_EventHandle;</span><br><span class="line"></span><br><span class="line">hi.arg2 = g_hkEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> bRet = IOControl(IOCTL_START,&amp;hi ,<span class="keyword">sizeof</span>(HANDLEINFO) ,<span class="literal">NULL</span> , <span class="number">1024</span> ,&amp;dwRet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建监听线程</span></span><br><span class="line"></span><br><span class="line">HANDLE  hThread = CreateThread(<span class="literal">NULL</span> , <span class="number">0</span> , (LPTHREAD_START_ROUTINE)&amp;WorkThread ,<span class="literal">NULL</span> ,<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">g_bIsRunnig = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>IOControl  函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOControl</span><span class="params">( <span class="keyword">int</span> Ctl_code, LPVOID InputBuffer, <span class="keyword">int</span> InputLen, LPVOID OutputBuffer, <span class="keyword">int</span> OutputLen, LPDWORD dwRet )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	HANDLE hDevice = CreateFile(<span class="string">"\\\\.\\KernelHandle"</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>,<span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( hDevice == INVALID_HANDLE_VALUE )</span><br><span class="line">&#123;</span><br><span class="line">		MessageBox( <span class="number">0</span>, <span class="string">"Failed To Open Device!"</span>, <span class="literal">NULL</span>, <span class="number">0</span> );</span><br><span class="line">				<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bRet = DeviceIoControl( hDevice, Ctl_code, InputBuffer, InputLen, OutputBuffer, OutputLen, dwRet, <span class="literal">NULL</span> );</span><br><span class="line">CloseHandle( hDevice );</span><br><span class="line"><span class="keyword">return</span>(bRet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkThread</span><span class="params">( LPVOID lParam )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dRet;</span><br><span class="line"></span><br><span class="line">	InitializeCriticalSection( &amp;g_cs );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ( g_bIsRunnig )</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">/* 等待同步时间 */</span></span><br><span class="line"></span><br><span class="line">		WaitForSingleObject( g_EventHandle, INFINITE ); <span class="comment">/* 等待 驱动程序 发出 信号 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> szBuffer[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">		WCHAR szMsgBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">		DWORD dwRet, nProcessId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		EnterCriticalSection( &amp;g_cs );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 接收到信号后 发出获取 本次信息 */</span></span><br><span class="line"></span><br><span class="line">		IOControl( IOCTL_GET_DATA, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;pi, <span class="keyword">sizeof</span>(pi), &amp;dwRet );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		CString cs;</span><br><span class="line"></span><br><span class="line">		MsgDialog dlg;</span><br><span class="line"></span><br><span class="line">		UCHARdata = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cs.Format( <span class="string">"%d "</span>, pi.PID );</span><br><span class="line"></span><br><span class="line">		dlg.m_id = cs;</span><br><span class="line"></span><br><span class="line">		cs.Format( <span class="string">"%s "</span>, pi.PATH );</span><br><span class="line"></span><br><span class="line">		dlg.m_path = cs;</span><br><span class="line"></span><br><span class="line">		cs.Format( <span class="string">"%s "</span>, pi.name );</span><br><span class="line"></span><br><span class="line">		dlg.m_name = cs;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( IDOK == dlg.DoModal() ) <span class="comment">/* 这个是一个对话框类 */</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 允许 */</span></span><br><span class="line"></span><br><span class="line">			data = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MessageBox ( 0, "允许" , "提示" ,MB_OK); */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		IOControl( IOCTL_SET_REPLY, &amp;data, <span class="number">1</span>, szBuffer, <span class="number">20</span>, &amp;dwRet );   <span class="comment">/* 设置好 用户 选择 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		LeaveCriticalSection( &amp;g_cs );</span><br><span class="line"></span><br><span class="line">		SetEvent( g_hkEvent );                                          <span class="comment">/* 通知内核 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 设置同步事件为无信号，等待下一次通知 */</span></span><br><span class="line"></span><br><span class="line">		ResetEvent( g_EventHandle );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DeleteCriticalSection( &amp;g_cs );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                
            </div>
        </article>
    
</div>
<div class="paginator">
    
        
        <a class="prev" href="/page/2/">
            <i class="iconfont icon-prev"></i>
            上一页
        </a>
        
        
        <a class="next" href="/page/4/">
            下一页
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    
    <a class="social-link" target="_blank" href="https://github.com/y11en">
        <i class="iconfont icon-github"></i>
    </a>
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
                2015 -
            
            2020
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin">y11en</a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    
    var gitment = new Gitment({
        id: '',
        owner: 'y11en',
        repo: 'y11en.github.io',
        oauth: {
            client_id: 'af81a082d027ddd8c33d',
            client_secret: '89ef5db8417e6c17d5f67b00895b3be2ed0b97f7'
        }
    });
    gitment.render('comment-container');
    

</script>
</html>
